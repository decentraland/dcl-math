## API Report File for "@dcl/ecs-math"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export class Angle {
    constructor(radians: number);
    static BetweenTwoPoints(a: Vector2, b: Vector2): Angle;
    degrees(): number;
    static FromDegrees(degrees: number): Angle;
    static FromRadians(radians: number): Angle;
    radians(): number;
}

// @public
export class Arc2 {
    constructor(
    startPoint: Vector2,
    midPoint: Vector2,
    endPoint: Vector2);
    angle: Angle;
    centerPoint: Vector2;
    endPoint: Vector2;
    midPoint: Vector2;
    orientation: Orientation;
    radius: number;
    startAngle: Angle;
    startPoint: Vector2;
}

// @public
export class Axis {
    static X: Vector3;
    static Y: Vector3;
    static Z: Vector3;
}

// @public
export class BezierCurve {
    static Interpolate(t: number, x1: number, y1: number, x2: number, y2: number): number;
}

// @public
export class Color3 {
    constructor(
    r?: number,
    g?: number,
    b?: number);
    add(otherColor: Color3): Color3;
    addToRef(otherColor: Color3, result: Color3): Color3;
    asArray(): number[];
    b: number;
    static Black(): Color3;
    static Blue(): Color3;
    clampToRef(min: number | undefined, max: number | undefined, result: Color3): Color3;
    clone(): Color3;
    copyFrom(source: Color3): Color3;
    copyFromFloats(r: number, g: number, b: number): Color3;
    equals(otherColor: Color3): boolean;
    equalsFloats(r: number, g: number, b: number): boolean;
    static FromArray(array: ArrayLike<number>, offset?: number): Color3;
    static FromHexString(hex: string): Color3;
    static FromInts(r: number, g: number, b: number): Color3;
    g: number;
    getClassName(): string;
    getHashCode(): number;
    static Gray(): Color3;
    static Green(): Color3;
    static Lerp(start: Color3, end: Color3, amount: number): Color3;
    static LerpToRef(left: Color3, right: Color3, amount: number, result: Color3): void;
    static Magenta(): Color3;
    multiply(otherColor: Color3): Color3;
    multiplyToRef(otherColor: Color3, result: Color3): Color3;
    static Purple(): Color3;
    r: number;
    static Random(): Color3;
    static Red(): Color3;
    scale(scale: number): Color3;
    scaleAndAddToRef(scale: number, result: Color3): Color3;
    scaleToRef(scale: number, result: Color3): Color3;
    set(r: number, g: number, b: number): Color3;
    subtract(otherColor: Color3): Color3;
    subtractToRef(otherColor: Color3, result: Color3): Color3;
    static Teal(): Color3;
    toArray(array: FloatArray, index?: number): Color3;
    toColor4(alpha?: number): Color4;
    toGammaSpace(): Color3;
    toGammaSpaceToRef(convertedColor: Color3): Color3;
    toHexString(): string;
    toJSON(): {
        r: number;
        g: number;
        b: number;
    };
    toLinearSpace(): Color3;
    toLinearSpaceToRef(convertedColor: Color3): Color3;
    toLuminance(): number;
    toString(): string;
    static White(): Color3;
    static Yellow(): Color3;
}

// @public
export class Color4 {
    constructor(
    r?: number,
    g?: number,
    b?: number,
    a?: number);
    a: number;
    add(right: Color4): Color4;
    addInPlace(right: Color4): Color4;
    asArray(): number[];
    b: number;
    static Black(): Color4;
    static Blue(): Color4;
    static CheckColors4(colors: number[], count: number): number[];
    clampToRef(min: number | undefined, max: number | undefined, result: Color4): Color4;
    static Clear(): Color4;
    clone(): Color4;
    copyFrom(source: Color4): Color4;
    copyFromFloats(r: number, g: number, b: number, a: number): Color4;
    static FromArray(array: ArrayLike<number>, offset?: number): Color4;
    static FromColor3(color3: Color3, alpha?: number): Color4;
    static FromHexString(hex: string): Color4;
    static FromInts(r: number, g: number, b: number, a: number): Color4;
    g: number;
    getClassName(): string;
    getHashCode(): number;
    static Gray(): Color4;
    static Green(): Color4;
    static Lerp(left: Color4, right: Color4, amount: number): Color4;
    static LerpToRef(left: Color4, right: Color4, amount: number, result: Color4): void;
    static Magenta(): Color4;
    multiply(color: Color4): Color4;
    multiplyToRef(color: Color4, result: Color4): Color4;
    static Purple(): Color4;
    r: number;
    static Red(): Color4;
    scale(scale: number): Color4;
    scaleAndAddToRef(scale: number, result: Color4): Color4;
    scaleToRef(scale: number, result: Color4): Color4;
    set(r: number, g: number, b: number, a: number): Color4;
    subtract(right: Color4): Color4;
    subtractToRef(right: Color4, result: Color4): Color4;
    static Teal(): Color4;
    toArray(array: number[], index?: number): Color4;
    toGammaSpace(): Color4;
    toGammaSpaceToRef(convertedColor: Color4): Color4;
    toHexString(): string;
    toLinearSpace(): Color4;
    toLinearSpaceToRef(convertedColor: Color4): Color4;
    toString(): string;
    static White(): Color4;
    static Yellow(): Color4;
}

// @public
export class Curve3 {
    constructor(points: Vector3[]);
    continue(curve: Curve3): Curve3;
    static CreateCatmullRomSpline(points: Vector3[], nbPoints: number, closed?: boolean): Curve3;
    static CreateCubicBezier(v0: Vector3, v1: Vector3, v2: Vector3, v3: Vector3, nbPoints: number): Curve3;
    static CreateHermiteSpline(p1: Vector3, t1: Vector3, p2: Vector3, t2: Vector3, nbPoints: number): Curve3;
    static CreateQuadraticBezier(v0: Vector3, v1: Vector3, v2: Vector3, nbPoints: number): Curve3;
    // (undocumented)
    getPoints(): Vector3[];
    // (undocumented)
    length(): number;
}

// @public
export const DEG2RAD: number;

// @public (undocumented)
export type double = number;

// @public
export const Epsilon = 0.000001;

// @public (undocumented)
export type float = number;

// @public (undocumented)
export type FloatArray = number[];

// @public
export class Frustum {
    static GetBottomPlaneToRef(transform: Matrix, frustumPlane: Plane): void;
    static GetFarPlaneToRef(transform: Matrix, frustumPlane: Plane): void;
    static GetLeftPlaneToRef(transform: Matrix, frustumPlane: Plane): void;
    static GetNearPlaneToRef(transform: Matrix, frustumPlane: Plane): void;
    static GetPlanes(transform: Matrix): Plane[];
    static GetPlanesToRef(transform: Matrix, frustumPlanes: Plane[]): void;
    static GetRightPlaneToRef(transform: Matrix, frustumPlane: Plane): void;
    static GetTopPlaneToRef(transform: Matrix, frustumPlane: Plane): void;
}

// @public
export interface ISize {
    height: number;
    width: number;
}

// Warning: (ae-internal-missing-underscore) The name "MathTmp" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export const MathTmp: {
    Vector3: Vector3[];
    Matrix: Matrix[];
    Quaternion: Quaternion[];
    staticUp: Readonly<Vector3>;
    tmpMatrix: Matrix;
};

// @public
export class Matrix {
    constructor();
    add(other: Matrix): Matrix;
    addAtIndex(index: number, value: number): Matrix;
    addToRef(other: Matrix, result: Matrix): Matrix;
    addToSelf(other: Matrix): Matrix;
    asArray(): Readonly<FloatArray>;
    clone(): Matrix;
    static Compose(scale: Vector3, rotation: Quaternion, translation: Vector3): Matrix;
    static ComposeToRef(scale: Vector3, rotation: Quaternion, translation: Vector3, result: Matrix): void;
    copyFrom(other: Readonly<Matrix>): Matrix;
    copyToArray(array: FloatArray, offset?: number): Matrix;
    decompose(scale?: Vector3, rotation?: Quaternion, translation?: Vector3): boolean;
    static DecomposeLerp(startValue: Matrix, endValue: Matrix, gradient: number): Matrix;
    static DecomposeLerpToRef(startValue: Matrix, endValue: Matrix, gradient: number, result: Matrix): void;
    determinant(): number;
    equals(value: Matrix): boolean;
    static FromArray(array: ArrayLike<number>, offset?: number): Matrix;
    static FromArrayToRef(array: ArrayLike<number>, offset: number, result: Matrix): void;
    static FromFloatArrayToRefScaled(array: FloatArray, offset: number, scale: number, result: Matrix): void;
    static FromQuaternionToRef(quat: Quaternion, result: Matrix): void;
    static FromValues(initialM11: number, initialM12: number, initialM13: number, initialM14: number, initialM21: number, initialM22: number, initialM23: number, initialM24: number, initialM31: number, initialM32: number, initialM33: number, initialM34: number, initialM41: number, initialM42: number, initialM43: number, initialM44: number): Matrix;
    static FromValuesToRef(initialM11: number, initialM12: number, initialM13: number, initialM14: number, initialM21: number, initialM22: number, initialM23: number, initialM24: number, initialM31: number, initialM32: number, initialM33: number, initialM34: number, initialM41: number, initialM42: number, initialM43: number, initialM44: number, result: Matrix): void;
    static FromXYZAxesToRef(xaxis: Vector3, yaxis: Vector3, zaxis: Vector3, result: Matrix): void;
    static GetAsMatrix2x2(matrix: Matrix): FloatArray;
    static GetAsMatrix3x3(matrix: Matrix): FloatArray;
    getClassName(): string;
    getHashCode(): number;
    getRotationMatrix(): Matrix;
    getRotationMatrixToRef(result: Matrix): Matrix;
    getRow(index: number): Nullable<Vector4>;
    getTranslation(): Vector3;
    getTranslationToRef(result: Vector3): Matrix;
    static Identity(): Matrix;
    static get IdentityReadOnly(): Readonly<Matrix>;
    static IdentityToRef(result: Matrix): void;
    static Invert(source: Matrix): Matrix;
    invert(): Matrix;
    invertToRef(other: Matrix): Matrix;
    isIdentity(): boolean;
    isIdentityAs3x2(): boolean;
    static Lerp(startValue: Matrix, endValue: Matrix, gradient: number): Matrix;
    static LerpToRef(startValue: Matrix, endValue: Matrix, gradient: number, result: Matrix): void;
    static LookAtLH(eye: Vector3, target: Vector3, up: Vector3): Matrix;
    static LookAtLHToRef(eye: Vector3, target: Vector3, up: Vector3, result: Matrix): void;
    static LookAtRH(eye: Vector3, target: Vector3, up: Vector3): Matrix;
    static LookAtRHToRef(eye: Vector3, target: Vector3, up: Vector3, result: Matrix): void;
    get m(): Readonly<FloatArray>;
    // @internal (undocumented)
    _markAsUpdated(): void;
    multiply(other: Readonly<Matrix>): Matrix;
    multiplyAtIndex(index: number, value: number): Matrix;
    multiplyToArray(other: Readonly<Matrix>, result: FloatArray, offset: number): Matrix;
    multiplyToRef(other: Readonly<Matrix>, result: Matrix): Matrix;
    static OrthoLH(width: number, height: number, znear: number, zfar: number): Matrix;
    static OrthoLHToRef(width: number, height: number, znear: number, zfar: number, result: Matrix): void;
    static OrthoOffCenterLH(left: number, right: number, bottom: number, top: number, znear: number, zfar: number): Matrix;
    static OrthoOffCenterLHToRef(left: number, right: number, bottom: number, top: number, znear: number, zfar: number, result: Matrix): void;
    static OrthoOffCenterRH(left: number, right: number, bottom: number, top: number, znear: number, zfar: number): Matrix;
    static OrthoOffCenterRHToRef(left: number, right: number, bottom: number, top: number, znear: number, zfar: number, result: Matrix): void;
    static PerspectiveFovLH(fov: number, aspect: number, znear: number, zfar: number): Matrix;
    static PerspectiveFovLHToRef(fov: number, aspect: number, znear: number, zfar: number, result: Matrix, isVerticalFovFixed?: boolean): void;
    static PerspectiveFovRH(fov: number, aspect: number, znear: number, zfar: number): Matrix;
    static PerspectiveFovRHToRef(fov: number, aspect: number, znear: number, zfar: number, result: Matrix, isVerticalFovFixed?: boolean): void;
    static PerspectiveFovWebVRToRef(fov: {
        upDegrees: number;
        downDegrees: number;
        leftDegrees: number;
        rightDegrees: number;
    }, znear: number, zfar: number, result: Matrix, rightHanded?: boolean): void;
    static PerspectiveLH(width: number, height: number, znear: number, zfar: number): Matrix;
    static Reflection(plane: Plane): Matrix;
    static ReflectionToRef(plane: Plane, result: Matrix): void;
    removeRotationAndScaling(): Matrix;
    reset(): Matrix;
    static RotationAxis(axis: Vector3, angle: number): Matrix;
    static RotationAxisToRef(axis: Vector3, angle: number, result: Matrix): void;
    static RotationX(angle: number): Matrix;
    static RotationXToRef(angle: number, result: Matrix): void;
    static RotationY(angle: number): Matrix;
    static RotationYawPitchRoll(yaw: number, pitch: number, roll: number): Matrix;
    static RotationYawPitchRollToRef(yaw: number, pitch: number, roll: number, result: Matrix): void;
    static RotationYToRef(angle: number, result: Matrix): void;
    static RotationZ(angle: number): Matrix;
    static RotationZToRef(angle: number, result: Matrix): void;
    scale(scale: number): Matrix;
    scaleAndAddToRef(scale: number, result: Matrix): Matrix;
    scaleToRef(scale: number, result: Matrix): Matrix;
    static Scaling(x: number, y: number, z: number): Matrix;
    static ScalingToRef(x: number, y: number, z: number, result: Matrix): void;
    setRow(index: number, row: Vector4): Matrix;
    setRowFromFloats(index: number, x: number, y: number, z: number, w: number): Matrix;
    setTranslation(vector3: Vector3): Matrix;
    setTranslationFromFloats(x: number, y: number, z: number): Matrix;
    toArray(): Readonly<FloatArray>;
    toggleModelMatrixHandInPlace(): void;
    toggleProjectionMatrixHandInPlace(): void;
    toNormalMatrix(ref: Matrix): void;
    static Translation(x: number, y: number, z: number): Matrix;
    static TranslationToRef(x: number, y: number, z: number, result: Matrix): void;
    static Transpose(matrix: Matrix): Matrix;
    transpose(): Matrix;
    static TransposeToRef(matrix: Matrix, result: Matrix): void;
    transposeToRef(result: Matrix): Matrix;
    updateFlag: number;
    static Zero(): Matrix;
}

// @public (undocumented)
export type Nullable<T> = T | null;

// @public
export enum Orientation {
    CCW = 1,
    CW = 0
}

// @public
export class Path2 {
    constructor(x: number, y: number);
    addArcTo(midX: number, midY: number, endX: number, endY: number, numberOfSegments?: number): Path2;
    addLineTo(x: number, y: number): Path2;
    close(): Path2;
    closed: boolean;
    getPointAtLengthPosition(normalizedLengthPosition: number): Vector2;
    getPoints(): Vector2[];
    length(): number;
    static StartingAt(x: number, y: number): Path2;
}

// @public
export class Path3D {
    constructor(
    path: Vector3[], firstNormal?: Nullable<Vector3>, raw?: boolean);
    getBinormals(): Vector3[];
    getCurve(): Vector3[];
    getDistances(): number[];
    getNormals(): Vector3[];
    getTangents(): Vector3[];
    path: Vector3[];
    update(path: Vector3[], firstNormal?: Nullable<Vector3>): Path3D;
}

// @public
export class Plane {
    constructor(a: number, b: number, c: number, d: number);
    // (undocumented)
    asArray(): number[];
    // (undocumented)
    clone(): Plane;
    copyFromPoints(point1: Vector3, point2: Vector3, point3: Vector3): Plane;
    d: number;
    dotCoordinate(point: Vector3): number;
    static FromArray(array: ArrayLike<number>): Plane;
    static FromPoints(point1: Vector3, point2: Vector3, point3: Vector3): Plane;
    static FromPositionAndNormal(origin: Vector3, normal: Vector3): Plane;
    // (undocumented)
    getClassName(): string;
    // (undocumented)
    getHashCode(): number;
    isFrontFacingTo(direction: Vector3, epsilon: number): boolean;
    normal: Vector3;
    normalize(): Plane;
    signedDistanceTo(point: Vector3): number;
    static SignedDistanceToPlaneFromPositionAndNormal(origin: Vector3, normal: Vector3, point: Vector3): number;
    transform(transformation: Matrix): Plane;
}

// Warning: (ae-incompatible-release-tags) The symbol "Quaternion" is marked as @public, but its signature references "ReadOnlyQuaternion" which is marked as @internal
//
// @public
export class Quaternion implements ReadOnlyQuaternion {
    constructor(
    x?: number,
    y?: number,
    z?: number,
    w?: number);
    // @internal
    add(other: Quaternion): Quaternion;
    // @internal
    addInPlace(other: Quaternion): Quaternion;
    static Angle(quat1: ReadOnlyQuaternion, quat2: ReadOnlyQuaternion): number;
    // (undocumented)
    angleAxis(degress: number, axis: Vector3): Quaternion;
    static AreClose(quat0: ReadOnlyQuaternion, quat1: ReadOnlyQuaternion): boolean;
    asArray(): number[];
    clone(): Quaternion;
    conjugate(): Quaternion;
    conjugateInPlace(): Quaternion;
    conjugateToRef(ref: Quaternion): Quaternion;
    copyFrom(other: ReadOnlyQuaternion): Quaternion;
    copyFromFloats(x: number, y: number, z: number, w: number): Quaternion;
    static Dot(left: ReadOnlyQuaternion, right: ReadOnlyQuaternion): number;
    equals(otherQuaternion: ReadOnlyQuaternion): boolean;
    static Euler(x: number, y: number, z: number): Quaternion;
    set eulerAngles(euler: Vector3);
    get eulerAngles(): Vector3;
    static FromArray(array: ArrayLike<number>, offset?: number): Quaternion;
    static FromEulerAnglesRef(x: number, y: number, z: number, result: Quaternion): void;
    static FromRotationMatrix(matrix: Matrix): Quaternion;
    fromRotationMatrix(matrix: Matrix): Quaternion;
    static FromRotationMatrixToRef(matrix: Matrix, result: Quaternion): void;
    static FromToRotation(from: Vector3, to: Vector3, up?: Vector3): Quaternion;
    getClassName(): string;
    getHashCode(): number;
    static Hermite(value1: ReadOnlyQuaternion, tangent1: ReadOnlyQuaternion, value2: ReadOnlyQuaternion, tangent2: ReadOnlyQuaternion, amount: number): Quaternion;
    static get Identity(): Quaternion;
    static Inverse(q: Quaternion): Quaternion;
    static IsIdentity(quaternion: ReadOnlyQuaternion): boolean;
    get length(): number;
    get lengthSquared(): number;
    static LookRotation(forward: Vector3, up?: Vector3): Quaternion;
    multiply(q1: ReadOnlyQuaternion): Quaternion;
    multiplyInPlace(q1: ReadOnlyQuaternion): Quaternion;
    multiplyToRef(q1: ReadOnlyQuaternion, result: Quaternion): Quaternion;
    normalize(): Quaternion;
    get normalized(): Quaternion;
    static RotateTowards(from: ReadOnlyQuaternion, to: Quaternion, maxDegreesDelta: number): Quaternion;
    static RotationAlphaBetaGamma(alpha: number, beta: number, gamma: number): Quaternion;
    static RotationAlphaBetaGammaToRef(alpha: number, beta: number, gamma: number, result: Quaternion): void;
    static RotationAxis(axis: Vector3, angle: number): Quaternion;
    static RotationAxisToRef(axis: Vector3, angle: number, result: Quaternion): Quaternion;
    static RotationQuaternionFromAxis(axis1: Vector3, axis2: Vector3, axis3: Vector3): Quaternion;
    static RotationQuaternionFromAxisToRef(axis1: Vector3, axis2: Vector3, axis3: Vector3, ref: Quaternion): void;
    static RotationYawPitchRoll(yaw: number, pitch: number, roll: number): Quaternion;
    static RotationYawPitchRollToRef(yaw: number, pitch: number, roll: number, result: Quaternion): void;
    scale(value: number): Quaternion;
    scaleAndAddToRef(scale: number, result: Quaternion): Quaternion;
    scaleInPlace(value: number): Quaternion;
    scaleToRef(scale: number, result: Quaternion): Quaternion;
    set(x: number, y: number, z: number, w: number): Quaternion;
    setEuler(x: number, y: number, z: number): Quaternion;
    setFromToRotation(from: Vector3, to: Vector3, up?: Vector3): void;
    static Slerp(left: ReadOnlyQuaternion, right: ReadOnlyQuaternion, amount: number): Quaternion;
    static SlerpToRef(left: ReadOnlyQuaternion, right: ReadOnlyQuaternion, amount: number, result: Quaternion): void;
    subtract(other: Quaternion): Quaternion;
    toRotationMatrix(result: Matrix): Quaternion;
    toString(): string;
    w: number;
    x: number;
    y: number;
    z: number;
    static Zero(): Quaternion;
}

// @public
export const RAD2DEG: number;

// @public (undocumented)
export type ReadOnlyColor4 = {
    readonly r: number;
    readonly g: number;
    readonly b: number;
    readonly a: number;
};

// Warning: (ae-internal-missing-underscore) The name "ReadOnlyQuaternion" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type ReadOnlyQuaternion = ReadOnlyVector4;

// Warning: (ae-internal-missing-underscore) The name "ReadOnlyVector2" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type ReadOnlyVector2 = {
    readonly y: number;
    readonly x: number;
};

// Warning: (ae-internal-missing-underscore) The name "ReadOnlyVector3" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type ReadOnlyVector3 = {
    readonly y: number;
    readonly x: number;
    readonly z: number;
};

// Warning: (ae-internal-missing-underscore) The name "ReadOnlyVector4" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type ReadOnlyVector4 = {
    readonly x: number;
    readonly y: number;
    readonly z: number;
    readonly w: number;
};

// @public
export class Scalar {
    static Clamp(value: number, min?: number, max?: number): number;
    static DeltaAngle(current: number, target: number): number;
    static Denormalize(normalized: number, min: number, max: number): number;
    static Hermite(value1: number, tangent1: number, value2: number, tangent2: number, amount: number): number;
    static InverseLerp(a: number, b: number, value: number): number;
    static Lerp(start: number, end: number, amount: number): number;
    static LerpAngle(start: number, end: number, amount: number): number;
    static Log2(value: number): number;
    static MoveTowards(current: number, target: number, maxDelta: number): number;
    static MoveTowardsAngle(current: number, target: number, maxDelta: number): number;
    static Normalize(value: number, min: number, max: number): number;
    static NormalizeRadians(angle: number): number;
    static PercentToRange(percent: number, min: number, max: number): number;
    static PingPong(tx: number, length: number): number;
    static RandomRange(min: number, max: number): number;
    static RangeToPercent(num: number, min: number, max: number): number;
    static Repeat(value: number, length: number): number;
    static Sign(value: number): number;
    static SmoothStep(from: number, to: number, tx: number): number;
    static ToHex(i: number): string;
    static TwoPi: number;
    static WithinEpsilon(a: number, b: number, epsilon?: number): boolean;
}

// @public
export class Size implements ISize {
    constructor(width: number, height: number);
    add(otherSize: Size): Size;
    clone(): Size;
    copyFrom(src: Size): void;
    copyFromFloats(width: number, height: number): Size;
    equals(other: Size): boolean;
    getClassName(): string;
    getHashCode(): number;
    height: number;
    static Lerp(start: Size, end: Size, amount: number): Size;
    multiplyByFloats(w: number, h: number): Size;
    set(width: number, height: number): Size;
    subtract(otherSize: Size): Size;
    get surface(): number;
    toString(): string;
    width: number;
    static Zero(): Size;
}

// @public
export enum Space {
    BONE = 2,
    LOCAL = 0,
    WORLD = 1
}

// @public
export const ToGammaSpace: number;

// @public
export const ToLinearSpace = 2.2;

// Warning: (ae-incompatible-release-tags) The symbol "Vector2" is marked as @public, but its signature references "ReadOnlyVector2" which is marked as @internal
//
// @public
export class Vector2 implements ReadOnlyVector2 {
    constructor(
    x?: number,
    y?: number);
    static Add(vector1: ReadOnlyVector2, vector2: ReadOnlyVector2): Vector2;
    add(otherVector: ReadOnlyVector2): Vector2;
    addInPlace(otherVector: ReadOnlyVector2): Vector2;
    addToRef(otherVector: ReadOnlyVector2, result: Vector2): Vector2;
    addVector3(otherVector: ReadOnlyVector2): Vector2;
    asArray(): number[];
    static CatmullRom(value1: ReadOnlyVector2, value2: ReadOnlyVector2, value3: ReadOnlyVector2, value4: ReadOnlyVector2, amount: number): Vector2;
    static Center(value1: ReadOnlyVector2, value2: ReadOnlyVector2): Vector2;
    static Clamp(value: ReadOnlyVector2, min: ReadOnlyVector2, max: ReadOnlyVector2): Vector2;
    clone(): Vector2;
    copyFrom(source: ReadOnlyVector2): Vector2;
    copyFromFloats(x: number, y: number): Vector2;
    static Distance(value1: Vector2, value2: Vector2): number;
    static DistanceOfPointFromSegment(p: Vector2, segA: Vector2, segB: Vector2): number;
    static DistanceSquared(value1: ReadOnlyVector2, value2: ReadOnlyVector2): number;
    divide(otherVector: ReadOnlyVector2): Vector2;
    divideInPlace(otherVector: ReadOnlyVector2): Vector2;
    divideToRef(otherVector: ReadOnlyVector2, result: Vector2): Vector2;
    static Dot(left: ReadOnlyVector2, right: ReadOnlyVector2): number;
    equals(otherVector: ReadOnlyVector2): boolean;
    equalsWithEpsilon(otherVector: ReadOnlyVector2, epsilon?: number): boolean;
    floor(): Vector2;
    fract(): Vector2;
    static FromArray(array: ArrayLike<number>, offset?: number): Vector2;
    static FromArrayToRef(array: ArrayLike<number>, offset: number, result: Vector2): void;
    getClassName(): string;
    getHashCode(): number;
    static Hermite(value1: ReadOnlyVector2, tangent1: ReadOnlyVector2, value2: ReadOnlyVector2, tangent2: ReadOnlyVector2, amount: number): Vector2;
    length(): number;
    lengthSquared(): number;
    static Lerp(start: ReadOnlyVector2, end: ReadOnlyVector2, amount: number): Vector2;
    static Maximize(left: ReadOnlyVector2, right: ReadOnlyVector2): Vector2;
    static Minimize(left: ReadOnlyVector2, right: ReadOnlyVector2): Vector2;
    multiply(otherVector: ReadOnlyVector2): Vector2;
    multiplyByFloats(x: number, y: number): Vector2;
    multiplyInPlace(otherVector: ReadOnlyVector2): Vector2;
    multiplyToRef(otherVector: ReadOnlyVector2, result: Vector2): Vector2;
    negate(): Vector2;
    static Normalize(vector: ReadOnlyVector2): Vector2;
    normalize(): Vector2;
    static One(): Vector2;
    static PointInTriangle(p: ReadOnlyVector2, p0: ReadOnlyVector2, p1: ReadOnlyVector2, p2: ReadOnlyVector2): boolean;
    scale(scale: number): Vector2;
    scaleAndAddToRef(scale: number, result: Vector2): Vector2;
    scaleInPlace(scale: number): Vector2;
    scaleToRef(scale: number, result: Vector2): Vector2;
    set(x: number, y: number): Vector2;
    subtract(otherVector: ReadOnlyVector2): Vector2;
    subtractInPlace(otherVector: ReadOnlyVector2): Vector2;
    subtractToRef(otherVector: ReadOnlyVector2, result: Vector2): Vector2;
    toArray(array: FloatArray, index?: number): Vector2;
    toString(): string;
    static Transform(vector: Vector2, transformation: Matrix): Vector2;
    static TransformToRef(vector: ReadOnlyVector2, transformation: Matrix, result: Vector2): void;
    x: number;
    y: number;
    static Zero(): Vector2;
}

// Warning: (ae-incompatible-release-tags) The symbol "Vector3" is marked as @public, but its signature references "ReadOnlyVector3" which is marked as @internal
//
// @public
export class Vector3 implements ReadOnlyVector3 {
    constructor(
    x?: number,
    y?: number,
    z?: number);
    static Add(vector1: ReadOnlyVector3, vector2: ReadOnlyVector3): Vector3;
    add(otherVector: ReadOnlyVector3): Vector3;
    addInPlace(otherVector: ReadOnlyVector3): Vector3;
    addInPlaceFromFloats(x: number, y: number, z: number): Vector3;
    addToRef(otherVector: ReadOnlyVector3, result: Vector3): Vector3;
    applyMatrix4(matrix: Matrix): void;
    applyMatrix4ToRef(matrix: Matrix, result: Vector3): Vector3;
    asArray(): number[];
    static Backward(): Vector3;
    static CatmullRom(value1: ReadOnlyVector3, value2: ReadOnlyVector3, value3: ReadOnlyVector3, value4: ReadOnlyVector3, amount: number): Vector3;
    static Center(value1: ReadOnlyVector3, value2: ReadOnlyVector3): Vector3;
    static Clamp(value: ReadOnlyVector3, min: ReadOnlyVector3, max: ReadOnlyVector3): Vector3;
    static ClampToRef(value: ReadOnlyVector3, min: ReadOnlyVector3, max: ReadOnlyVector3, result: Vector3): void;
    clone(): Vector3;
    copyFrom(source: ReadOnlyVector3): Vector3;
    copyFromFloats(x: number, y: number, z: number): Vector3;
    static Cross(left: ReadOnlyVector3, right: ReadOnlyVector3): Vector3;
    static CrossToRef(left: ReadOnlyVector3, right: ReadOnlyVector3, result: Vector3): void;
    static Distance(value1: ReadOnlyVector3, value2: ReadOnlyVector3): number;
    static DistanceSquared(value1: ReadOnlyVector3, value2: ReadOnlyVector3): number;
    divide(otherVector: ReadOnlyVector3): Vector3;
    divideInPlace(otherVector: ReadOnlyVector3): Vector3;
    divideToRef(otherVector: ReadOnlyVector3, result: Vector3): Vector3;
    static Dot(left: ReadOnlyVector3, right: ReadOnlyVector3): number;
    static Down(): Vector3;
    equals(otherVector: ReadOnlyVector3): boolean;
    equalsToFloats(x: number, y: number, z: number): boolean;
    equalsWithEpsilon(otherVector: ReadOnlyVector3, epsilon?: number): boolean;
    floor(): Vector3;
    static Forward(): Vector3;
    fract(): Vector3;
    static FromArray(array: ArrayLike<number>, offset?: number): Vector3;
    static FromArrayToRef(array: ArrayLike<number>, offset: number, result: Vector3): void;
    static FromFloatArray(array: FloatArray, offset?: number): Vector3;
    static FromFloatArrayToRef(array: FloatArray, offset: number, result: Vector3): void;
    static FromFloatsToRef(x: number, y: number, z: number, result: Vector3): void;
    static GetAngleBetweenVectors(vector0: Vector3, vector1: Vector3, normal: ReadOnlyVector3): number;
    getClassName(): string;
    static GetClipFactor(vector0: ReadOnlyVector3, vector1: ReadOnlyVector3, axis: ReadOnlyVector3, size: number): number;
    getHashCode(): number;
    static Hermite(value1: ReadOnlyVector3, tangent1: ReadOnlyVector3, value2: ReadOnlyVector3, tangent2: ReadOnlyVector3, amount: number): Vector3;
    get isNonUniform(): boolean;
    static Left(): Vector3;
    length(): number;
    lengthSquared(): number;
    static Lerp(start: ReadOnlyVector3, end: ReadOnlyVector3, amount: number): Vector3;
    static LerpToRef(start: ReadOnlyVector3, end: ReadOnlyVector3, amount: number, result: Vector3): void;
    static Maximize(left: Vector3, right: Vector3): Vector3;
    maximizeInPlace(other: ReadOnlyVector3): Vector3;
    maximizeInPlaceFromFloats(x: number, y: number, z: number): Vector3;
    static Minimize(left: ReadOnlyVector3, right: ReadOnlyVector3): Vector3;
    minimizeInPlace(other: ReadOnlyVector3): Vector3;
    minimizeInPlaceFromFloats(x: number, y: number, z: number): Vector3;
    multiply(otherVector: ReadOnlyVector3): Vector3;
    multiplyByFloats(x: number, y: number, z: number): Vector3;
    multiplyInPlace(otherVector: ReadOnlyVector3): Vector3;
    multiplyToRef(otherVector: ReadOnlyVector3, result: Vector3): Vector3;
    negate(): Vector3;
    static Normalize(vector: Vector3): Vector3;
    normalize(): Vector3;
    normalizeFromLength(len: number): Vector3;
    normalizeToNew(): Vector3;
    static NormalizeToRef(vector: Vector3, result: Vector3): void;
    normalizeToRef(reference: Vector3): Vector3;
    static One(): Vector3;
    static Right(): Vector3;
    rotate(q: Quaternion): Vector3;
    rotateToRef(q: Quaternion, result: Vector3): Vector3;
    static RotationFromAxis(axis1: Vector3, axis2: Vector3, axis3: Vector3): Vector3;
    static RotationFromAxisToRef(axis1: Vector3, axis2: Vector3, axis3: Vector3, ref: Vector3): void;
    scale(scale: number): Vector3;
    scaleAndAddToRef(scale: number, result: Vector3): Vector3;
    scaleInPlace(scale: number): Vector3;
    scaleToRef(scale: number, result: Vector3): Vector3;
    set(x: number, y: number, z: number): Vector3;
    setAll(v: number): Vector3;
    subtract(otherVector: ReadOnlyVector3): Vector3;
    subtractFromFloats(x: number, y: number, z: number): Vector3;
    subtractFromFloatsToRef(x: number, y: number, z: number, result: Vector3): Vector3;
    subtractInPlace(otherVector: ReadOnlyVector3): Vector3;
    subtractToRef(otherVector: ReadOnlyVector3, result: Vector3): Vector3;
    toArray(array: FloatArray, index?: number): Vector3;
    toQuaternion(): Quaternion;
    toString(): string;
    static TransformCoordinates(vector: ReadOnlyVector3, transformation: Matrix): Vector3;
    static TransformCoordinatesFromFloatsToRef(x: number, y: number, z: number, transformation: Readonly<Matrix>, result: Vector3): void;
    static TransformCoordinatesToRef(vector: ReadOnlyVector3, transformation: Readonly<Matrix>, result: Vector3): void;
    static TransformNormal(vector: ReadOnlyVector3, transformation: Matrix): Vector3;
    static TransformNormalFromFloatsToRef(x: number, y: number, z: number, transformation: Readonly<Matrix>, result: Vector3): void;
    static TransformNormalToRef(vector: ReadOnlyVector3, transformation: Readonly<Matrix>, result: Vector3): void;
    static Up(): Vector3;
    x: number;
    y: number;
    z: number;
    static Zero(): Vector3;
}

// Warning: (ae-incompatible-release-tags) The symbol "Vector4" is marked as @public, but its signature references "ReadOnlyVector4" which is marked as @internal
//
// @public
export class Vector4 implements ReadOnlyVector4 {
    constructor(
    x: number,
    y: number,
    z: number,
    w: number);
    static Add(vector1: ReadOnlyVector4, vector2: ReadOnlyVector4): Vector4;
    add(otherVector: ReadOnlyVector4): Vector4;
    addInPlace(otherVector: ReadOnlyVector4): Vector4;
    addToRef(otherVector: ReadOnlyVector4, result: Vector4): Vector4;
    asArray(): number[];
    static Center(value1: ReadOnlyVector4, value2: ReadOnlyVector4): Vector4;
    clone(): Vector4;
    copyFrom(source: ReadOnlyVector4): Vector4;
    copyFromFloats(x: number, y: number, z: number, w: number): Vector4;
    static Distance(value1: ReadOnlyVector4, value2: ReadOnlyVector4): number;
    static DistanceSquared(value1: ReadOnlyVector4, value2: ReadOnlyVector4): number;
    divide(otherVector: ReadOnlyVector4): Vector4;
    divideInPlace(otherVector: ReadOnlyVector4): Vector4;
    divideToRef(otherVector: ReadOnlyVector4, result: Vector4): Vector4;
    equals(otherVector: ReadOnlyVector4): boolean;
    equalsToFloats(x: number, y: number, z: number, w: number): boolean;
    equalsWithEpsilon(otherVector: ReadOnlyVector4, epsilon?: number): boolean;
    floor(): Vector4;
    fract(): Vector4;
    static FromArray(array: ArrayLike<number>, offset?: number): Vector4;
    static FromArrayToRef(array: ArrayLike<number>, offset: number, result: Vector4): void;
    static FromFloatArrayToRef(array: FloatArray, offset: number, result: Vector4): void;
    static FromFloatsToRef(x: number, y: number, z: number, w: number, result: Vector4): void;
    getClassName(): string;
    getHashCode(): number;
    length(): number;
    lengthSquared(): number;
    static Maximize(left: ReadOnlyVector4, right: ReadOnlyVector4): Vector4;
    maximizeInPlace(other: ReadOnlyVector4): Vector4;
    static Minimize(left: ReadOnlyVector4, right: ReadOnlyVector4): Vector4;
    minimizeInPlace(other: ReadOnlyVector4): Vector4;
    multiply(otherVector: ReadOnlyVector4): Vector4;
    multiplyByFloats(x: number, y: number, z: number, w: number): Vector4;
    multiplyInPlace(otherVector: ReadOnlyVector4): Vector4;
    multiplyToRef(otherVector: ReadOnlyVector4, result: Vector4): Vector4;
    negate(): Vector4;
    static Normalize(vector: ReadOnlyVector4): Vector4;
    normalize(): Vector4;
    static NormalizeToRef(vector: ReadOnlyVector4, result: Vector4): void;
    static One(): Vector4;
    scale(scale: number): Vector4;
    scaleAndAddToRef(scale: number, result: Vector4): Vector4;
    scaleInPlace(scale: number): Vector4;
    scaleToRef(scale: number, result: Vector4): Vector4;
    set(x: number, y: number, z: number, w: number): Vector4;
    setAll(v: number): Vector4;
    subtract(otherVector: ReadOnlyVector4): Vector4;
    subtractFromFloats(x: number, y: number, z: number, w: number): Vector4;
    subtractFromFloatsToRef(x: number, y: number, z: number, w: number, result: Vector4): Vector4;
    subtractInPlace(otherVector: ReadOnlyVector4): Vector4;
    subtractToRef(otherVector: ReadOnlyVector4, result: Vector4): Vector4;
    toArray(array: FloatArray, index?: number): Vector4;
    toString(): string;
    toVector3(): Vector3;
    static TransformNormal(vector: ReadOnlyVector4, transformation: Matrix): Vector4;
    static TransformNormalFromFloatsToRef(x: number, y: number, z: number, w: number, transformation: Matrix, result: Vector4): void;
    static TransformNormalToRef(vector: ReadOnlyVector4, transformation: Matrix, result: Vector4): void;
    w: number;
    x: number;
    y: number;
    z: number;
    static Zero(): Vector4;
}

// (No @packageDocumentation comment for this package)

```
